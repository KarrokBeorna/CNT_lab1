# CNT_lab1a - Блокирующие сокеты

## Протокол

1. Установка соединения при запуске клиента
2. Обмен данными в любой момент, пока не разорвано соединение
3. Завершение соединения

## Пакет

### Сообщения клиента:

Авторизация:  
`{lenMsg (2 bytes)}\x00{username}`

Выход:  
`{lenMsg (2 bytes)}\x01{>>exit<<}`

Сообщение с файлом:  
`{lenMsg (2 bytes)}\x02{filesize (4 bytes)}{filename}{msg(опционально)}`

Сообщения без файла:  
`{lenMsg (2 bytes)}\x03{msg}`

Изменение имени:  
`{lenMsg (2 bytes)}\x04{>>chname<< username}`

### Ответы сервера:

Успешная авторизация:  
`{lenMsg (2 bytes)}\x00{msg}`

Сообщение с файлом:  
`{lenMsg (2 bytes)}\x02{time}{[username]}\xff{filesize (4 bytes)}{filename}{msg(опционально)}`

Сообщение без файла:  
`{lenMsg (2 bytes)}\x03{msg}`

Имя пользователя успешно изменено:  
`{lenMsg (2 bytes)}\x04{msg}`

## Запуск

- Запуск сервера
- Запуск клиентов

## Передача данных

- Первое сообщение - авторизация, если такое имя пользователя не используется, то сервер посылает сообщение с байтом `\x00`
- Обычные сообщения с ограничением примерно в `2^16 - 1` символов
- Сообщения с файлом `>>sendfile<< {filename} {msg}(опционально}`

Файлы обязательно должны храниться в папке files в директории скрипта, хотя это легко изменить

## Изменение имени пользователя

- Отправка серверу сообщения `>>chname<< {username}`
- Отправка сервером ответа с байтом типа `\x04`, если такое имя пользователя свободно, иначе просто сообщение с байтом типа `\x03`
- В моем случае, конечно, еще можно было изменить название директории, куда должны приходить файлы, однако это на данный момент не важно

## Закрытие сокетов

Выйти из чата можно при помощи отправки сообщения `>>exit<<`

# CNT_lab1b - Неблокирующие сокеты

## Краткое описание отличий от блокирующих:

1. На стороне сервера в случае блокирующих мы создаем отдельный поток на каждого клиента, затем, уже внутри них, постоянно ждем, пока не придут какие-либо данные. В случае неблокирующих же мы имеем лишь один поток, в котором используется метод `select` из одноименной библиотеки, блокирующий поток до прихода каких-либо данных от одного из активных клиентов. После обнаружения какой-либо активности начинается обход сокетов, которые попали в массив `read`. По хорошему еще бы стоило обрабатывать массивы `write` и `err`, однако в моем случае нет в этом необходимости.
2. Следует использовать `try: ... catch BlockingIOError: ... else: ...`, чтобы сервер постоянно не падал из-за ошибки \[Win 10035\]

# Примеры использования

1. Авторизация и обмен сообщениями:  

![image](https://user-images.githubusercontent.com/43076360/144421242-0185f5f4-2eb4-4338-9a4b-76c3712c530d.png)

2. Обмен файлами с сообщением и без:

![image](https://user-images.githubusercontent.com/43076360/144422017-6268f5ed-eb9d-41bd-bf68-f9ccd513fa0b.png)

3. Выход из чата:

![image](https://user-images.githubusercontent.com/43076360/144422493-5ae876f2-9c19-4d43-8fa3-a873c8fe0079.png)

4. Изменение имени пользователя (зашли под одним, вышли под другим - причем берется лишь первое слово до пробела):

![image](https://user-images.githubusercontent.com/43076360/144423446-7cde4059-33f1-490e-8f6d-2c1864642d04.png)

